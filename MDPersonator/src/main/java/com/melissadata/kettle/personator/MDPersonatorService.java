package com.melissadata.kettle.personator;

import java.util.ArrayList;
import java.util.List;

import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.logging.LogChannelInterface;
import org.pentaho.di.core.variables.VariableSpace;

import com.melissadata.cz.MDProps;
import com.melissadata.cz.support.MDPropTags;
import com.melissadata.kettle.personator.web.PersonatorWebService;

public abstract class MDPersonatorService {
	/**
	 * Called to allocate the service handler based on the service type
	 *
	 * @param checkData
	 * @param checkMeta
	 * @param space
	 * @param log
	 * @return
	 */
	public static MDPersonatorService create(MDPersonatorData checkData, MDPersonatorMeta checkMeta, VariableSpace space, LogChannelInterface log) {
		MDPersonatorService service = new PersonatorWebService(checkData, checkMeta, space, log);
		return service;
	}
	protected MDPersonatorData		checkData;
	protected MDPersonatorMeta		checkMeta;
	protected VariableSpace			space;
	protected LogChannelInterface	log;
	protected boolean				testing;
	protected boolean				initFailed;

	public MDPersonatorService(MDPersonatorData checkData, MDPersonatorMeta checkMeta, VariableSpace space, LogChannelInterface log) {
		this.checkData = checkData;
		this.checkMeta = checkMeta;
		this.space = space;
		this.log = log;
		initFailed = false;
	}

	/**
	 * Called to create a request object for this service type
	 *
	 * @param ioMeta
	 * @param inputData
	 * @return
	 */
	public abstract MDPersonatorRequest buildRequest(IOMetaHandler ioMeta, Object[] inputData);

	public boolean checkProxy() {
		return true;
	}

	/**
	 * Create a request manager for processing requests in an asynchronous manner
	 *
	 */
	protected IRequestManager createRequestManager() {
		// If this is a local service then we only allow one thread in the thread pool.
		// Otherwise, we use the configured thread count.
		int maxThreads = Integer.parseInt(MDProps.getProperty(MDPropTags.TAG_PERSONATOR_THREADS, "1"));
		return new RequestManager(maxThreads);
	}

	/**
	 * Called to determine the service route to use for this request. This is currently only used for change of address
	 * requests.
	 * US change of address requests are routed to the first queue while Canadian are routed to the second queue.
	 *
	 * All other types of reuquests are routed to the first queue.
	 *
	 * @param request
	 * @return
	 * @throws KettleException
	 */
	public abstract int determineRequestRoute(MDPersonatorRequest request) throws KettleException;

	/**
	 * Called to dispose of service resources
	 */
	public void dispose() {
		// No base resources
	}

	/**
	 * Called to initialize the service handler
	 *
	 * @throws KettleException
	 */
	public void init() throws KettleException {
		// Allocate request array
		checkData.requests = new ArrayList<List<MDPersonatorRequest>>(2);
		checkData.requests.add(new ArrayList<MDPersonatorRequest>());
		checkData.requests.add(new ArrayList<MDPersonatorRequest>());
	}

	/**
	 * Called to output the data from the queued results
	 *
	 * @param queue
	 */
	public abstract void outputData(List<MDPersonatorRequest> requests, int queue);

	/**
	 * Called to process the queued requests
	 *
	 * @param requests
	 * @param queue
	 *
	 * @throws KettleException
	 */
	public abstract void processRequests(List<MDPersonatorRequest> requests, int queue, int attempts) throws KettleException;

	/**
	 * Called to save any reports generated by the service
	 * 
	 * @throws KettleException
	 */
	public abstract void saveReports() throws KettleException;

	/**
	 * Called to set the testing mode
	 *
	 * @param testing
	 */
	public void setTesting(boolean testing) {
		this.testing = testing;
	}

	/**
	 * Called to test the customer status
	 * 
	 * @throws KettleException
	 */
	public void testCustomerStatus() throws KettleException {
		// Default is to do nothing
	}
}

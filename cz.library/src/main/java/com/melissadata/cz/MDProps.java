package com.melissadata.cz;

import java.io.*;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.io.FileUtils;
import org.pentaho.di.core.Const;
import org.pentaho.di.core.Props;

/**
 * Manages Melissadata / ContactZone properties.
 */
public class MDProps {

	private static final String PROPS_FILENAME        = "mdProps.prop";
	private static final String TAG_CONTACT_ZONE_FILE = "contact_zone.prp";
	private static final String NEW_PREFIX            = "NEW.";
	private static final int    NEW_PREFIX_LENGTH     = NEW_PREFIX.length();
	private static final String RESET_PREFIX          = "RESET.";
	private static final int    RESET_PREFIX_LENGTH   = RESET_PREFIX.length();

	/**
	 * Retrieves the property file.
	 *
	 * @return The location of the property file
	 * @throws IOException
	 */
	private static File getPropFile() throws IOException {

		// Look for properties file in the CZ work directory
		return new File(CZUtil.getCZWorkDirectory(), PROPS_FILENAME);
	}

	/**
	 * Used to retrieve the temporary prop file
	 *
	 * @return The location of the temp property file
	 * @throws IOException
	 */
	private File getTmpPropFile() throws IOException {
		// Look for properties file in the CZ work directory
		File tmpProp = new File(CZUtil.getCZWorkDirectory() + Const.FILE_SEPARATOR + "tmp", PROPS_FILENAME);
		if (tmpProp.exists()) {
			return tmpProp;
		}

		return tmpProp;
	}

	private static class INSTANCE {

		static final MDProps instance;
		static {
			instance = new MDProps();
		}
	}

	/**
	 * Called to get the singleton instance
	 *
	 * @return static instance.
	 */
	private static MDProps getProps() {
		// REturn the singleton instance
		return INSTANCE.instance;
	}

	/**
	 * Called to get cz properties.
	 *
	 * @return A copy of all the current pristine properties
	 */
	public static Properties getProperties() {

		return getProps()._getProperties();
	}

	/**
	 * Called to get the value of a persistent property.
	 *
	 * @param key          The name of the property.
	 * @param defaultValue The value to be returned if property is not found
	 * @return the value of the property defined by key or default value if not found.
	 */
	public static String getProperty(String key, String defaultValue) {

		return getProps()._getProperty(key, defaultValue);
	}

	/**
	 * Called to set the value of a persistent property
	 *
	 * @param key   The name of the property.
	 * @param value the value to set.
	 */
	public static void setProperty(String key, String value) {

		getProps()._setProperty(key, value);
	}

	/**
	 * Called to load the current values of the persistent properties
	 */
	public static void load() {

		getProps()._load();
	}

	/**
	 * Called to flush the current values of the persistent properties to disk.
	 *
	 * @throws IOException
	 */
	public static void save() throws IOException {

		getProps()._save(false);
	}

	/**
	 * Revert any unsaved changes to persistent properties
	 */
	public static void revert() {

		getProps()._revert();
	}

	/**
	 * @return Any exception generated by the load process
	 */
	public static IOException getLoadException() {

		return getProps()._getLoadException();
	}

	/**
	 * Called to update the current running version of ContactZone.
	 *
	 * @throws java.io.IOException if Props not found or cant be accessed.
	 */
	public static void updateCZ() throws java.io.IOException {

		Props.getInstance().setProperty("ContactZone", getProps()._getVersion());
		Props.getInstance().saveProps();
	}

	private Properties  tmpProps;
	private Properties  props;
	private Properties  cleanProps;
	private IOException loadException;

	private MDProps() {

	}

	/**
	 * Called to load the properties
	 */
	private synchronized void _load() {
		// If properties haven't been loaded then load them now
		if (props == null) {
			props = new Properties();

			// Get the properties from the properties file
			InputStream in = null;
			try {
				boolean changed = false;

				// Look for the properties file
				File propFile = getPropFile();
				if (propFile.exists()) {
					// Read the properties file
					in = new BufferedInputStream(new FileInputStream(propFile));
					props.load(in);
				} else {
					// must be first install set changed to
					// tell it to do its thing
					changed = true;
				}

				// Check for new and reset properties
				changed = _checkProps() || changed;

				// If properties changed in some way during this load then we
				// need to immediately re-save it
				if (changed) {
					_save(true);
					_saveTmp(changed);
				}
			} catch (IOException e) {
				// Save it for later
				loadException = e;
			} finally {
				if (in != null) {
					try {
						in.close();
					} catch (IOException ignored) {
					}
				}
			}
		}
	}

	/**
	 * Called to load the temp properties
	 */
	private synchronized void getTmpProps() {
		// If properties haven't been loaded then load them now
		if (tmpProps == null) {
			tmpProps = new Properties();

			// Get the properties from the properties file
			InputStream in = null;
			try {
				// Look for the properties file
				File propFile = getTmpPropFile();
				if (!propFile.exists()) {
					throw new FileNotFoundException("Could not find properties file: " + propFile);
				}

				// Read the properties file
				in = new BufferedInputStream(new FileInputStream(propFile));
				tmpProps.load(in);
			} catch (IOException e) {
				// Save it for later
				loadException = e;
			} finally {
				if (in != null) {
					try {
						in.close();
					} catch (IOException ignored) {
					}
				}
			}
		}
	}

	/**
	 * This code is called right after the properties are loaded for the first
	 * time. It will check for new and reset properties.
	 *
	 * @return true if properties were changed
	 */
	private boolean _checkProps() {

		boolean changed = false;
		_checkKettleFolder();

		getTmpProps();
		Properties tmpClone = (Properties) tmpProps.clone();

		// look for
		for (Map.Entry<?, ?> entry : tmpClone.entrySet()) {
			String key   = (String) entry.getKey();
			String value = (String) entry.getValue();

			// If this is a new property ...
			if (key.startsWith(NEW_PREFIX)) {

				// Remove it
				tmpProps.remove(key);
				props.remove(key);

				// Strip the prefix and check to see if the key already exists
				key = key.substring(NEW_PREFIX_LENGTH);
				if (!props.containsKey(key)) {

					// If it doesn't then add the new key/value pair back into
					// the properties
					props.put(key, value);
				}

				tmpProps.put(key, value);

				// Changed, need to update
				changed = true;
			}

			// If this is a reset property ...
			else if (key.startsWith(RESET_PREFIX)) {

				// Remove it
				tmpProps.remove(key);
				props.remove(key);

				// Strip the prefix and add the new key/value pair to the
				// properties
				// (effectively resets any previous value)
				key = key.substring(RESET_PREFIX_LENGTH);
				props.put(key, value);
				tmpProps.put(key, value);

				// Changed, need to update
				changed = true;
			}
		}

		return changed;
	}

	/**
	 * Called on initial load.  Checks for any resources that need to be updated.
	 */
	private void _checkKettleFolder() {

		File kettleMD    = new File(Const.getKettleDirectory(), "MD");
		File mdResources = new File("mdKettle");
		/**
		 If mdResources exists we know it is ContactZone. If it doesn't exist then it is
		 Pentaho and this will be skipped.
		 */
		System.out.println("Checking for MDkettle Resources");
		if ((!kettleMD.exists() || _isUpdate()) && mdResources.exists()) {
			//System.out.println("Coppy Kettle folders");
			File kettle   = new File(Const.getKettleDirectory());
			File mu       = new File(mdResources, "matchup");
			File muglobal = new File(mdResources, "matchup.global");
			File md       = new File(mdResources, "MD");
			File tmp      = new File(mdResources, "tmp");

			try {
				FileUtils.copyDirectoryToDirectory(mu, kettle);
				FileUtils.copyDirectoryToDirectory(muglobal, kettle);
				FileUtils.copyDirectoryToDirectory(md, kettle);
				FileUtils.copyDirectoryToDirectory(tmp, kettle);
				System.out.println("Successfully copied MDkettle resources to " + kettle.getAbsolutePath());
			} catch (IOException ioe) {
				System.out.println(" Error coping MDkettle resources: " + ioe.getMessage());
			}
		} else {
			System.out.println("MDkettle resources up to date");
		}
	}

	/**
	 *  Called to check if app need to be updated
	 * @return true if current version != installed version
	 */
	private boolean _isUpdate() {

		String insVer     = null;
		String curVersion = null;
		try {
			insVer = _getInstalledVersion();
			curVersion = _getVersion();
		} catch (java.io.IOException ioe) {
			System.out.println("Failed to get version : " + ioe.getMessage());
		}

		//System.out.println("Compare Versions: " + insVer + " - " + curVersion);
		if (!insVer.equals(curVersion)) {
			//updateCZ(curVersion);
			return true;
		}
		return false;
	}

	/**
	 * Calle to get the current running version.
	 * @return The current version number read from TAG_CONTACT_ZONE_FILE
	 * @throws java.io.IOException
	 */
	private String _getVersion() throws java.io.IOException {

		String         version  = "0";
		File           kettleUI = new File("ui" + Const.FILE_SEPARATOR + TAG_CONTACT_ZONE_FILE);
		BufferedReader br       = new BufferedReader(new FileReader(kettleUI));
		String         line     = null;
		while ((line = br.readLine()) != null) {
			if (line.trim().startsWith("Version")) {
				version = line.substring(8);
			}
		}
		br.close();
		if (version == null) {
			version = "0";
		}
		return version;
	}

	/**
	 *
	 * Called to get the currently installed version.
	 * @return The Installed version number as read from spoon.rc
	 * @throws java.io.IOException
	 */
	private String _getInstalledVersion() throws java.io.IOException {

		String version = "-1";
		File   spoonrc = new File(Const.getKettleDirectory() + Const.FILE_SEPARATOR + ".spoonrc");
		if (!spoonrc.exists()) {
			return version;
		}
		BufferedReader br   = new BufferedReader(new FileReader(spoonrc));
		String         line = null;
		while ((line = br.readLine()) != null) {
			if (line.startsWith("ContactZone")) {
				version = line.substring(12);
			}
		}
		br.close();
		return version;
	}

	/**
	 * Called to persist the current properties
	 *
	 * @throws IOException
	 */
	private synchronized void _save(boolean force) throws IOException {
		// Don't need to save if not dirty
		if (cleanProps == null && !force) {
			return;
		}

		// Save the new properties
		BufferedOutputStream out = null;
		try {
			File propFile = getPropFile();
			out = new BufferedOutputStream(new FileOutputStream(propFile));
			props.store(out, "Contact Zone Properties");

			// Not dirty anymore
			cleanProps = null;
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException ignored) {
				}
			}
		}
	}

	/**
	 * Called to persist the current properties
	 *
	 * @throws IOException
	 */
	private synchronized void _saveTmp(boolean changed) throws IOException {

		if (!changed) {
			return;
		}
		// Save the new properties
		BufferedOutputStream out = null;
		try {
			File propFile = getTmpPropFile();
			out = new BufferedOutputStream(new FileOutputStream(propFile));
			tmpProps.store(out, "Contact Zone Properties");
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException ignored) {
				}
			}
		}
	}

	/**
	 * Get the persistent property value
	 *
	 * @param key
	 * @param defaultValue
	 * @return
	 */
	private synchronized String _getProperty(String key, String defaultValue) {

		if (props != null) {
			return props.getProperty(key, defaultValue);
		}
		return defaultValue;
	}

	/**
	 * Change a persistent property value
	 *
	 * @param key
	 * @param newValue
	 */
	private synchronized void _setProperty(String key, String newValue) {
		// Create empty properties if not already loaded
		if (props == null) {
			props = new Properties();
		}

		// If this is the first change to persistent properties then save them
		// for possible revert
		if (cleanProps == null) {
			// Do nothing if no change
			String oldValue = props.getProperty(key);
			if (oldValue == null || !oldValue.equals(newValue)) {
				cleanProps = (Properties) props.clone();
			}
		}

		// Change the property
		props.setProperty(key, newValue);
	}

	/**
	 * @return A copy of all persistent properties
	 */
	private synchronized Properties _getProperties() {

		return (Properties) props.clone();
	}

	/**
	 * Revert changed properties to previous saved state
	 */
	private void _revert() {

		if (cleanProps != null) {
			props = cleanProps;
			cleanProps = null;
		}
	}

	/**
	 * return Any exception generated by the load process
	 */
	private IOException _getLoadException() {

		return loadException;
	}
}
